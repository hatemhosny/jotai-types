// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   react
//   jotai/vanilla

declare module 'jotai' {
    export * from 'jotai/vanilla';
    export * from 'jotai/react';
}

declare module 'jotai/vanilla' {
    export { atom } from 'jotai/vanilla/atom';
    export type { Atom, WritableAtom, PrimitiveAtom } from 'jotai/vanilla/atom';
    export { createStore, getDefaultStore } from 'jotai/vanilla/store';
    export type { Getter, Setter, ExtractAtomValue, ExtractAtomArgs, ExtractAtomResult, SetStateAction, } from 'jotai/vanilla/typeUtils';
}

declare module 'jotai/react' {
    export { Provider, useStore } from 'jotai/react/Provider';
    export { useAtomValue } from 'jotai/react/useAtomValue';
    export { useSetAtom } from 'jotai/react/useSetAtom';
    export { useAtom } from 'jotai/react/useAtom';
}

declare module 'jotai/vanilla/atom' {
    type Getter = <Value>(atom: Atom<Value>) => Value;
    type Setter = <Value, Args extends unknown[], Result>(atom: WritableAtom<Value, Args, Result>, ...args: Args) => Result;
    type SetAtom<Args extends unknown[], Result> = <A extends Args>(...args: A) => Result;
    /**
        * setSelf is for internal use only and subject to change without notice.
        */
    type Read<Value, SetSelf = never> = (get: Getter, options: {
            readonly signal: AbortSignal;
            readonly setSelf: SetSelf;
    }) => Value;
    type Write<Args extends unknown[], Result> = (get: Getter, set: Setter, ...args: Args) => Result;
    type WithInitialValue<Value> = {
            init: Value;
    };
    type OnUnmount = () => void;
    type OnMount<Args extends unknown[], Result> = <S extends SetAtom<Args, Result>>(setAtom: S) => OnUnmount | void;
    export interface Atom<Value> {
            toString: () => string;
            read: Read<Value>;
            debugLabel?: string;
            /**
                * To ONLY be used by Jotai libraries to mark atoms as private. Subject to change.
                * @private
                */
            debugPrivate?: boolean;
    }
    export interface WritableAtom<Value, Args extends unknown[], Result> extends Atom<Value> {
            read: Read<Value, SetAtom<Args, Result>>;
            write: Write<Args, Result>;
            onMount?: OnMount<Args, Result>;
    }
    type SetStateAction<Value> = Value | ((prev: Value) => Value);
    export type PrimitiveAtom<Value> = WritableAtom<Value, [
            SetStateAction<Value>
    ], void>;
    export function atom<Value, Args extends unknown[], Result>(read: Read<Value, SetAtom<Args, Result>>, write: Write<Args, Result>): WritableAtom<Value, Args, Result>;
    export function atom<Value>(read: Read<Value>): Atom<Value>;
    export function atom<Value, Args extends unknown[], Result>(initialValue: Value, write: Write<Args, Result>): WritableAtom<Value, Args, Result> & WithInitialValue<Value>;
    export function atom<Value>(initialValue: Value): PrimitiveAtom<Value> & WithInitialValue<Value>;
    export {};
}

declare module 'jotai/vanilla/store' {
    import type { Atom, WritableAtom } from 'jotai/vanilla/atom';
    type AnyValue = unknown;
    type AnyError = unknown;
    type AnyAtom = Atom<AnyValue>;
    type OnUnmount = () => void;
    /**
        * Immutable map from a dependency to the dependency's atom state
        * when it was last read.
        * We can skip recomputation of an atom by comparing the atom state
        * of each dependency to that dependencies's current revision.
        */
    type Dependencies = Map<AnyAtom, AtomState>;
    /**
        * Immutable atom state,
        * tracked for both mounted and unmounted atoms in a store.
        */
    type AtomState<Value = AnyValue> = {
            d: Dependencies;
    } & ({
            e: AnyError;
    } | {
            v: Value;
    });
    type Listeners = Set<() => void>;
    type Dependents = Set<AnyAtom>;
    /**
        * State tracked for mounted atoms. An atom is considered "mounted" if it has a
        * subscriber, or is a transitive dependency of another atom that has a
        * subscriber.
        *
        * The mounted state of an atom is freed once it is no longer mounted.
        */
    type Mounted = {
            /** The list of subscriber functions. */
            l: Listeners;
            /** Atoms that depend on *this* atom. Used to fan out invalidation. */
            t: Dependents;
            /** Function to run when the atom is unmounted. */
            u?: OnUnmount;
    };
    type StoreListenerRev2 = (action: {
            type: 'write';
            flushed: Set<AnyAtom>;
    } | {
            type: 'async-write';
            flushed: Set<AnyAtom>;
    } | {
            type: 'sub';
            flushed: Set<AnyAtom>;
    } | {
            type: 'unsub';
    } | {
            type: 'restore';
            flushed: Set<AnyAtom>;
    }) => void;
    /**
        * Create a new store. Each store is an independent, isolated universe of atom
        * states.
        *
        * Jotai atoms are not themselves state containers. When you read or write an
        * atom, that state is stored in a store. You can think of a Store like a
        * multi-layered map from atoms to states, like this:
        *
        * ```
        * // Conceptually, a Store is a map from atoms to states.
        * // The real type is a bit different.
        * type Store = Map<VersionObject, Map<Atom, AtomState>>
        * ```
        *
        * @returns A store.
        */
    export const createStore: () => {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: AnyAtom, listener: () => void) => () => void;
            dev_subscribe_store: (l: StoreListenerRev2, rev: 2) => () => void;
            dev_get_mounted_atoms: () => IterableIterator<AnyAtom>;
            dev_get_atom_state: (a: AnyAtom) => AtomState<unknown> | undefined;
            dev_get_mounted: (a: AnyAtom) => Mounted | undefined;
            dev_restore_atoms: (values: Iterable<readonly [AnyAtom, AnyValue]>) => void;
    } | {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: AnyAtom, listener: () => void) => () => void;
            dev_subscribe_store?: never;
            dev_get_mounted_atoms?: never;
            dev_get_atom_state?: never;
            dev_get_mounted?: never;
            dev_restore_atoms?: never;
    };
    export const getDefaultStore: () => {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: AnyAtom, listener: () => void) => () => void;
            dev_subscribe_store: (l: StoreListenerRev2, rev: 2) => () => void;
            dev_get_mounted_atoms: () => IterableIterator<AnyAtom>;
            dev_get_atom_state: (a: AnyAtom) => AtomState<unknown> | undefined;
            dev_get_mounted: (a: AnyAtom) => Mounted | undefined;
            dev_restore_atoms: (values: Iterable<readonly [AnyAtom, AnyValue]>) => void;
    } | {
            get: <Value>(atom: Atom<Value>) => Value;
            set: <Value_1, Args extends unknown[], Result>(atom: WritableAtom<Value_1, Args, Result>, ...args: Args) => Result;
            sub: (atom: AnyAtom, listener: () => void) => () => void;
            dev_subscribe_store?: never;
            dev_get_mounted_atoms?: never;
            dev_get_atom_state?: never;
            dev_get_mounted?: never;
            dev_restore_atoms?: never;
    };
    export {};
}

declare module 'jotai/vanilla/typeUtils' {
    import type { Atom, PrimitiveAtom, WritableAtom } from 'jotai/vanilla/atom';
    export type Getter = Parameters<Atom<unknown>['read']>[0];
    export type Setter = Parameters<WritableAtom<unknown, unknown[], unknown>['write']>[1];
    export type ExtractAtomValue<AtomType> = AtomType extends Atom<infer Value> ? Value : never;
    export type ExtractAtomArgs<AtomType> = AtomType extends WritableAtom<any, infer Args, any> ? Args : never;
    export type ExtractAtomResult<AtomType> = AtomType extends WritableAtom<any, any[], infer Result> ? Result : never;
    export type SetStateAction<Value> = ExtractAtomArgs<PrimitiveAtom<Value>>[0];
}

declare module 'jotai/react/Provider' {
    import type { FunctionComponentElement, ReactNode } from 'react';
    import { createStore } from 'jotai/vanilla';
    type Store = ReturnType<typeof createStore>;
    type Options = {
        store?: Store;
    };
    export const useStore: (options?: Options) => Store;
    export const Provider: ({ children, store, }: {
        children?: ReactNode;
        store?: Store;
    }) => FunctionComponentElement<{
        value: Store | undefined;
    }>;
    export {};
}

declare module 'jotai/react/useAtomValue' {
    import type { Atom, ExtractAtomValue } from 'jotai/vanilla';
    import { useStore } from 'jotai/react/Provider';
    type Store = ReturnType<typeof useStore>;
    type Options = {
        store?: Store;
        delay?: number;
    };
    export function useAtomValue<Value>(atom: Atom<Value>, options?: Options): Awaited<Value>;
    export function useAtomValue<AtomType extends Atom<any>>(atom: AtomType, options?: Options): Awaited<ExtractAtomValue<AtomType>>;
    export {};
}

declare module 'jotai/react/useSetAtom' {
    import type { ExtractAtomArgs, ExtractAtomResult, WritableAtom } from 'jotai/vanilla';
    import { useStore } from 'jotai/react/Provider';
    type SetAtom<Args extends any[], Result> = (...args: Args) => Result;
    type Store = ReturnType<typeof useStore>;
    type Options = {
        store?: Store;
    };
    export function useSetAtom<Value, Args extends any[], Result>(atom: WritableAtom<Value, Args, Result>, options?: Options): SetAtom<Args, Result>;
    export function useSetAtom<AtomType extends WritableAtom<any, any[], any>>(atom: AtomType, options?: Options): SetAtom<ExtractAtomArgs<AtomType>, ExtractAtomResult<AtomType>>;
    export {};
}

declare module 'jotai/react/useAtom' {
    import type { Atom, ExtractAtomArgs, ExtractAtomResult, ExtractAtomValue, WritableAtom } from 'jotai/vanilla';
    import { useAtomValue } from 'jotai/react/useAtomValue';
    type SetAtom<Args extends any[], Result> = (...args: Args) => Result;
    type Options = Parameters<typeof useAtomValue>[1];
    export function useAtom<Value, Args extends any[], Result>(atom: WritableAtom<Value, Args, Result>, options?: Options): [Awaited<Value>, SetAtom<Args, Result>];
    export function useAtom<Value>(atom: Atom<Value>, options?: Options): [Awaited<Value>, never];
    export function useAtom<AtomType extends WritableAtom<any, any[], any>>(atom: AtomType, options?: Options): [
        Awaited<ExtractAtomValue<AtomType>>,
        SetAtom<ExtractAtomArgs<AtomType>, ExtractAtomResult<AtomType>>
    ];
    export function useAtom<AtomType extends Atom<any>>(atom: AtomType, options?: Options): [Awaited<ExtractAtomValue<AtomType>>, never];
    export {};
}

